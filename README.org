#+STARTUP: entitiespretty
#+STARTUP: showall indent
#+STARTUP: hidestars
#+OPTIONS: \n:t

* COMMENT requirement

#+BEGIN_SRC emacs-lisp
  (require 'yasnippet)
  (require 'ob-scheme)
  (require 'ob-js)
  (require 'ob-scala)
  (require 'ob-ruby)
#+END_SRC

#+RESULTS:
: ob-ruby

* Introduction & Guide

** About this repo

This is a workshop for introduce the Continuation Passing Style (CPS) of functional programming.

** How to run

#+BEGIN_SRC shell
  git clone git@github.com:SanCoder-Q/cps-ws.git
  cd cps-ws
  npm install
  npm start
#+END_SRC

** How to test

Jasmine 2.3 is used in this repo for unit test.

#+BEGIN_SRC scheme
  npm test
#+END_SRC

* Simple Linked List

To introduce the CPS, it's better to introduce it with benefit. A important application scenario of CPS is to apply iteration elegantly. Hence, we are going to implement a linked list using *java script* (since everyone should be familiar with it).

A linked list is composed of two memory-adjacent elements: ~Head~ and ~Tail~. The ~Head~ storage a piece of data and the ~Tail~ point to the next ~Head~ if it exist, otherwise it should be empty (~undefined~).

A simple ~List~ with a recursive constructor has already defined in ~app.js~. Implement the ~List.prototype.forEach~ function to passing the test.

*Notice* : Please do *NOT* use any loop syntaxes in your method implement e.g. ~for~ or ~while~ or any loop method in dear ~lodash~.

* Change it to immutable function

Now you should notice that the ~forEach~ method is a mutable function: It takes two arguments a ~List~ object and an operation function. Plus, it never return. So you cannot use it in a chain. That's not very good.

Can you do something magic to make it immutable and return the operated new ~List~ object. Please pass all the tests without changing them. Still, do not use any loop syntaxes. They are just *syntax sugar*. And you need to see what behind them.

* Tail recursion

Since the ES6 has already standardized the *tail call optimization* feature, there is a very strong possibility that V8 will have this feature.

Tail call optimization is a compile technology. It can optimize the function call at the end of the parent function. For instance:

#+BEGIN_SRC js
  function Caller() {
    var arg;
    // do something with arg
    return Callee(arg);
  }
#+END_SRC

Tail call optimization is applying in a lot of compilers and interpreters in many different languages including C++, Java, C#, Scala, Lisp etc. *One key point is it can change the recursion to iteration.* For example:

#+BEGIN_SRC js
  // A recursive factorial function, but not tail recursion.
  function factorial(n) {
    return n ? n * factorial(n-1) : 1;
  }
  result = factorial(5);
  //     = 5 * factorial(4)
  //     = 5 * (4 * factorial(3))
  //     = 5 * (4 * (3 * factorial(2)))
  //     = 5 * (4 * (3 * (2 * factorial(1))))
  //     = 5 * (4 * (3 * (2 * (1 * factorial(0)))))
  //     = 5 * (4 * (3 * (2 * (1 * 1))))
  //     = 5 * (4 * (3 * (2 * 1)))
  //     = 5 * (4 * (3 * 2))
  //     = 5 * (4 * 6)
  //     = 5 * 24
  //     = 120
#+END_SRC

#+BEGIN_SRC js
  // A recursive factorial function, but not tail recursion.
  function factorial(n, result) {
    return n ? factorial(n-1, n * result) : result;
  }
  result = factorial(5, 1);
  //     = factorial(4, 1 * 5)
  //     = factorial(3, 5 * 4)
  //     = factorial(2, 3 * 20)
  //     = factorial(1, 2 * 60)
  //     = factorial(0, 1 * 120)
  //     = 120
#+END_SRC

Hence, an important feature of the optimization is to reduce the frequent stack using.

We can change our ~forEach~ function to fit the huge data requirement in our ~List~. Using *tail recursion* to pass the same test. Good Luck!

* CPS is coming

So, you finished it, congratulations!

But, you wrote two recursion, right? Think about what if our List is pretty huge? What if the List has higher dimension (, means the element of the list may also a list)?

Is there a possible way to do the recursion just once?

Of course there is a way: using CPS! It's easy to implement, easier than what it sounds and looks.

** What's CPS?

Continuation-passing style is a magical, but simple style of *functional programming* in which control is passed explicitly in the form of a continuation.
CPS is different from direct style programming which we usually use. The function written in CPS takes an extra argument: an explicit *continuation function* usually with only one argument. When the CPS function got a result which returned by the direct style function, it *returns* the result by calling the continuation function with the value as the argument. This means when invoking a CPS function, it requires a *callback function* to deal with the returned value. For example:

- JavaScript
  + Direct style
    #+BEGIN_SRC js
      var square = _ => _ * _;
      return square(2);
    #+END_SRC

    #+RESULTS:
    : 4

  + CPS
    #+BEGIN_SRC js
      var identity = _ => _;
      var square = (_, f) => f(_ * _);
      return square(2, identity);
    #+END_SRC

    #+RESULTS:
    : 4

Can you see it? You can just send the ~then function~ as a parameter of the current function, the ~then function~ will deal with the result, and in the end, give the new result to the next ~then function~ until we get what we want. Yes, when you do something like ~.then(...)~ or continus Ajax request, you are using CPS.

The above logic is not pure CPS. It's just a description because we using the ~identity~ to get the final result but ~identity~ is not a CPS definition. Pure CPS is not recommended, especially in a non functional programming language. But sometimes, we can use it to achieve our purpose, and sometimes it help us to comprehend the compiler running principle and Monad.

** Eventually why CPS?

- To understand how compiler working while the function invoked.
- Force the compiler or interpreter to run the code in order.
- Give you a chain style to orgnize your logic.
- Make every recursion to tail recursion.

** Let's do it!

Using CPS to make your ~forEach~ not only loop once but also a tail recursion.

** Step by step:

#+BEGIN_SRC js
  List.prototype.forEach = function(op) {
    function forEachIter(src, f) {
      if(src.tail) {
        return forEachIter(
          src.tail,
          (dst) => f(List.cons(op(src.head), dst))
        );
      } else {
        return f(List.cons(op(src.head), undefined));
      }
    }
    return forEachIter(this, _ => _);
  };

  // If this = (1, (2, (3, undefined)))
  // forEachIter(this, _=>_)
  // forEachIter((2, (3, undefined)), x => List.cons(op(1), x))
  // forEachIter((3, undefined), x => List.cons(op(1), List.cons(op(2), x)))
  // (x => List.cons(op(1), List.cons(op(2), x)))(List.cons(op(3), undefined))
  // (op(1), (op(2), (op(3), undefined)))
#+END_SRC

** More
Implement ~List.prototype.foldRight~ methods using cps and pass the test.
